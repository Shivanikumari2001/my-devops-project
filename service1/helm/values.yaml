# replicaCount: 1

# image:
#   repository: service1
#   tag: "final"
#   pullPolicy: Never
#   # repository: service1
#   # tag: "latest"
#   # pullPolicy: Never

# imagePullSecrets: []
# nameOverride: ""
# fullnameOverride: ""

# serviceAccount:
#   create: true
#   annotations: {}
#   name: ""

# podAnnotations: {}

# podSecurityContext: {}

# securityContext: {}

# service:
#   type: ClusterIP
#   port: 3001

# ingress:
#   enabled: false
#   className: ""
#   annotations: {}
#   hosts:
#     - host: service1.local
#       paths:
#         - path: /
#           pathType: Prefix
#   tls: []

# resources:
#   limits:
#     cpu: 500m
#     memory: 512Mi
#   requests:
#     cpu: 250m
#     memory: 256Mi

# autoscaling:
#   enabled: false
#   minReplicas: 2
#   maxReplicas: 5
#   targetCPUUtilizationPercentage: 80

# nodeSelector: {}

# tolerations: []

# affinity: {}

# env:
#   - name: HTTP_PORT
#     value: "3001"
#   - name: TCP_PORT
#     value: "3003"
#   - name: NODE_ENV
#     value: "production"


replicaCount: 1

image:
  repository: service1              # Local Minikube image
  tag: "final"                      # Must match your Minikube image tag
  pullPolicy: Never                 # Because image is already inside Minikube (no pulling from DockerHub)

imagePullSecrets: []

service:
  type: ClusterIP
  port: 3001

env:
  - name: PORT
    value: "3001"
  - name: NODE_ENV
    value: "production"

livenessProbe:
  httpGet:
    path: /health
    port: 3001
  initialDelaySeconds: 15
  periodSeconds: 10

readinessProbe:
  httpGet:
    path: /health
    port: 3001
  initialDelaySeconds: 10
  periodSeconds: 5

resources:
  requests:
    cpu: "250m"
    memory: "256Mi"
  limits:
    cpu: "500m"
    memory: "512Mi"

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 3
  targetCPUUtilizationPercentage: 80
